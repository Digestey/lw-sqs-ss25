"""Database SQL Injection Pentests (and more)"""
from unittest.mock import patch
import bcrypt
from testcontainers.mysql import MySqlContainer
import os
import time
import pytest
import mysql.connector
from app.services.database_service import *


@pytest.mark.asyncio
async def test_sql_injection_registration(client, mysql_container):
    """SQL injection during registration. Malicious username should either be rejected or treated as a normal usename"""
    malicious_username = "' OR '1'='1"
    password = "securePass123"

    response = client.post("/api/register", json={
        "username": malicious_username,
        "password": password
    })

    assert response.status_code == 201

    port = mysql_container.get_exposed_port(3306)
    conn = get_connection(port)

    try:
        user = get_user(conn, malicious_username)
        assert user is not None
        assert user["username"] == malicious_username
    finally:
        conn.close()

def test_sql_injection_login(client):
    """Same thing but with login"""
    response = client.post("/api/token", data={
        "username": "' OR '1'='1",
        "password": "any"
    })
    # should fail (incorrect password at the very least)
    assert response.status_code in (401, 403)

def test_login_without_password(client):
    """No password"""
    response = client.post("/api/token", data={
        "username": "someuser"
        # trying without password field, here!
    })
    assert response.status_code == 422  # FastAPI should catch this

def test_login_empty_credentials(client):
    """As Gordon Ramsay famously said, 'How about nothing?'"""
    response = client.post("/api/token", data={
        "username": "",
        "password": ""
    })
    assert response.status_code == 403 or response.status_code == 401

def test_login_sql_injection_password(client):
    """# This assumes the user "testuser" exists, but we'll try to bypass with SQL"""
    client.post("/api/register", json={
        "username": "testuser",
        "password": "securepass123"
    })

    response = client.post("/api/token", data={
        "username": "testuser",
        "password": "' OR '1'='1"
    })

    # It should NOT succeed
    assert response.status_code == 403 or response.status_code == 401
    assert "access_token" not in response.text

def test_access_with_fake_token(client):
    """Access denied with fake token"""
    fake_token = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.FAKE.PARTS"
    response = client.get(
        "/api/highscores",
        headers={"Authorization": fake_token}
    )
    assert response.status_code == 401 or response.status_code == 403

def test_no_password_hash_in_login_response(client):
    """No password hash in login response"""
    client.post("/api/register", json={
        "username": "hashcheck",
        "password": "safePassword123"
    })

    response = client.post("/api/token", data={
        "username": "hashcheck",
        "password": "safePassword123"
    })

    assert response.status_code == 200
    assert "password_hash" not in response.text.lower()

def test_protected_highscore_without_token(client):
    """Token defense works"""
    response = client.get("/api/highscore/10")  # assuming protected
    assert response.status_code == 401 or response.status_code == 403